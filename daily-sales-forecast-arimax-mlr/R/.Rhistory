p <- autoplot(ts_train, xlab = "Year", ylab = y_label) +
autolayer(ts_test, series = "Actual", PI = FALSE)
for (i in seq_along(forecasts)) {
p <- p + autolayer(forecasts[[i]], series = forecast_names[i], PI = FALSE)
}
p + ggtitle("Forecast Comparison")
}
run_baseline_arima <- function() {
cat("\n=== BASELINE ARIMA MODEL ===\n")
sales <- load_sales_data(SALES_DATA_PATH)
split_data <- split_train_test(sales, TRAIN_END)
plot_diagnostics(split_data$train, split_data$test, 'Sales')
result <- fit_and_forecast(split_data$train[, 'Sales'], h = 32)
plot(result$forecast)
acc <- accuracy(result$forecast, split_data$test[, "Sales"])
print(acc)
result
}
run_arimax_model <- function(regressor_cols, model_name) {
cat(paste0("\n=== ", model_name, " ===\n"))
sales <- load_sales_data(SALES_DATA_PATH)
split_data <- split_train_test(sales, TRAIN_END)
plot_diagnostics(split_data$train, split_data$test, 'Sales')
xreg_train <- split_data$train[, regressor_cols]
xreg_test <- split_data$test[, regressor_cols]
result <- fit_and_forecast(split_data$train[, 'Sales'],
xreg_train, xreg_test)
plot(result$forecast)
acc <- accuracy(result$forecast, split_data$test[, "Sales"])
print(acc)
result
}
run_posts_forecast <- function() {
cat("\n=== POSTS ARIMA FORECASTING ===\n")
posts_df <- read.csv(POSTS_DATA_PATH, header = TRUE, stringsAsFactors = FALSE)
posts <- ts(posts_df, start = TS_START, frequency = TS_FREQUENCY)
split_data <- split_train_test(posts, TRAIN_END)
plot_diagnostics(split_data$train, split_data$test, 'Posts')
kpss.test(split_data$train[, 'Posts'])
result <- fit_and_forecast(split_data$train[, 'Posts'],
h = length(split_data$test))
plot(result$forecast)
acc <- accuracy(result$forecast, split_data$test[, "Posts"])
print(acc)
# Forecast on full data
fit_full <- arima(posts[, 'Posts'], order = c(1, 0, 4))
summary(fit_full)
checkresiduals(fit_full)
fcast_full <- forecast(fit_full, h = FORECAST_HORIZON)
plot(fcast_full)
posts_forecast <- as.data.frame(fcast_full)
xreg_posts_fc <- as.matrix(posts_forecast$`Point Forecast`)
write.csv(xreg_posts_fc, 'fore_posts.csv', row.names = FALSE)
list(model = fit_full, forecast = fcast_full,
forecast_vector = xreg_posts_fc)
}
run_final_model <- function() {
cat("\n=== FINAL PRODUCTION MODEL ===\n")
sales <- load_sales_data(SALES_DATA_PATH)
finalxreg_df <- read.csv(FINALXREG_PATH, header = TRUE,
stringsAsFactors = FALSE)
finalxreg <- ts(finalxreg_df, start = FORECAST_START,
frequency = TS_FREQUENCY)
acf(sales[, 'Sales'])
pacf(sales[, 'Sales'])
xreg_sales <- sales[, c(5, 8, 9)]
fit <- Arima(sales[, 'Sales'], xreg = xreg_sales, order = c(0, 0, 2))
print(summary(fit))
checkresiduals(fit)
fcast <- forecast(fit, xreg = finalxreg)
plot(fcast)
autoplot(sales[, 'Sales'], xlab = "Year", ylab = "Daily Sales") +
autolayer(fcast, series = "ARIMAX", PI = FALSE) +
ggtitle("Final Forecast from ARIMAX Model")
print(fcast)
final_forecast <- as.data.frame(fcast)
write.csv(final_forecast$`Point Forecast`,
'forecastedsales_2weeks.csv', row.names = FALSE)
write.csv(final_forecast,
'forecastedsales_2weeks_wconf.csv', row.names = FALSE)
list(model = fit, forecast = fcast)
}
run_brute_force_selection <- function() {
cat("\n=== BRUTE FORCE MODEL SELECTION ===\n")
sales <- load_sales_data(SALES_DATA_PATH)
split_data <- split_train_test(sales, TRAIN_END)
reg_cols <- 3:9
results <- list()
idx <- 1
for (k in 1:length(reg_cols)) {
combos <- combn(reg_cols, k, simplify = FALSE)
for (combo in combos) {
combo_name <- paste0("cols_", paste(combo, collapse = "_"))
xreg_train <- split_data$train[, combo, drop = FALSE]
xreg_test <- split_data$test[, combo, drop = FALSE]
fit <- auto.arima(split_data$train[, 'Sales'],
xreg = xreg_train,
trace = FALSE,
approximation = FALSE)
fcast <- forecast(fit, xreg = xreg_test)
acc <- accuracy(fcast, split_data$test[, 'Sales'])
results[[idx]] <- tibble(
model = combo_name,
arima = paste(fit$arma[c(1, 6, 2)], collapse = ","),
AICc = fit$aicc,
BIC = fit$bic,
RMSE_test = acc["Test set", "RMSE"],
MAE_test = acc["Test set", "MAE"],
MAPE_test = acc["Test set", "MAPE"]
)
idx <- idx + 1
}
}
results_df <- bind_rows(results)
top_models <- results_df %>%
filter(MAPE_test <= 50) %>%
arrange(RMSE_test)
print(top_models, n = Inf)
top_models
}
compare_models <- function() {
cat("\n=== MODEL COMPARISON ===\n")
sales <- load_sales_data(SALES_DATA_PATH)
split_data <- split_train_test(sales, TRAIN_END)
# Baseline ARIMA
baseline <- fit_and_forecast(split_data$train[, 'Sales'], h = 32)
# Best RMSE: ARIMAX with Fiesta, Promo
model1 <- run_arimax_model(c(5, 8), "Best RMSE Model")
# Best MAPE: ARIMAX with Fiesta, Promo, Posts
model2 <- run_arimax_model(c(5, 8, 9), "Best MAPE Model")
# MLR: ARIMAX with Fiesta, Holiday, Promo, Posts
model3 <- run_arimax_model(c(5, 6, 8, 9), "MLR Method Model")
# Calculate residuals
actual <- split_data$test[, "Sales"]
res_baseline <- actual - baseline$forecast$mean
res1 <- actual - model1$forecast$mean
res2 <- actual - model2$forecast$mean
res3 <- actual - model3$forecast$mean
residuals_df <- cbind(res1, res2, res3, res_baseline)
colnames(residuals_df) <- c("Best RMSE", "Best MAPE", "MLR Method", "ARIMA only")
residuals_ts <- ts(residuals_df, start = 1, frequency = 1)
autoplot(residuals_ts, xlab = "Day", ylab = "Residuals") +
ggtitle("Residual Comparison")
# Plot forecasts
actual_ts <- ts(split_data$test[, 'Sales'], start = 1, frequency = 1)
autoplot(actual_ts, xlab = "Days", ylab = "Sales", series = "Actual Sales") +
autolayer(ts(model1$forecast$mean, start = 1, frequency = 1),
series = "Best RMSE", PI = FALSE) +
autolayer(ts(model2$forecast$mean, start = 1, frequency = 1),
series = "Best MAPE", PI = FALSE) +
autolayer(ts(model3$forecast$mean, start = 1, frequency = 1),
series = "MLR Method", PI = FALSE) +
ggtitle("Forecast Comparison")
# Print accuracies
cat("\nBaseline ARIMA Accuracy:\n")
print(accuracy(baseline$forecast, split_data$test[, "Sales"]))
cat("\nBest RMSE Model Accuracy:\n")
print(accuracy(model1$forecast, split_data$test[, "Sales"]))
cat("\nBest MAPE Model Accuracy:\n")
print(accuracy(model2$forecast, split_data$test[, "Sales"]))
cat("\nMLR Method Model Accuracy:\n")
print(accuracy(model3$forecast, split_data$test[, "Sales"]))
}
main <- function() {
# Run baseline model
baseline_results <- run_baseline_arima()
# Compare multiple ARIMAX specifications
compare_models()
# Forecast posts
posts_results <- run_posts_forecast()
# Run final production model
final_results <- run_final_model()
# Optional: Run brute force model selection
# brute_force_results <- run_brute_force_selection()
}
# CONFIGURE TIME SERIES
sales_df = read.csv('/Users/zakbeltran/Documents/MathModFCO/cc6mon.csv', header=TRUE, stringsAsFactors=FALSE)
library('ggplot2')
library('forecast')
library('tseries')
library('tidyverse')
# CONFIGURE TIME SERIES
sales_df = read.csv('/Users/zakbeltran/Documents/MathModFCO/cc6mon.csv', header=TRUE, stringsAsFactors=FALSE)
# CONFIGURE TIME SERIES
sales_df = read.csv('/Users/zakbeltran/Documents/Documents/MathModFCO/cc6mon.csv', header=TRUE, stringsAsFactors=FALSE)
# CONFIGURE TIME SERIES
sales_df = read.csv('/Users/zakbeltran/Documents/Documents/MathModFCO/cc6mon.csv', header=TRUE, stringsAsFactors=FALSE)
sales <- ts(sales_df[,'Sales'], start = c(2024,306), frequency = 365)
plot(sales)
# SPLIT TIME SERIES TO TRAIN AND TEST DATA
ts_train <- window(sales,start=c(2024,306),end=c(2025,90))
ts_test  <- window(sales,start=c(2025,90))
# CHECK ACF
acf(ts_train)
autoplot(ts_train1,legendLabs = c("Train set 1"),xlab="Year",series="Train set") +
autolayer(ts_test1,series = "Test set1") +
ggtitle("Data split 1")
autoplot(ts_train1,legendLabs = c("Train set 1"),xlab="Year",series="Train set") +
autolayer(ts_test1,series = "Test set1") +
ggtitle("Data split 1")
autoplot(ts_train,legendLabs = c("Train set 1"),xlab="Year",series="Train set") +
autolayer(ts_test,series = "Test set1") +
ggtitle("Data split 1")
fit_ARIMA <- auto.arima(ts_train, seasonal = FALSE, approximation=FALSE, trace=TRUE)
print(summary(fit_ARIMA))
checkresiduals(fit_ARIMA)
fcastA <- fit_ARIMA %>%
forecast(h = 32)
autoplot
plot(fcastA)
reg_cols <- c(3:9)
results <- list()
i <- 1
for (k in 1:length(reg_cols)) {
combos <- combn(reg_cols, k, simplify = FALSE)
for (combo in combos) {
combo_name <- paste0("cols_", paste(combo, collapse = "_"))
xreg_train <- ts_train[, combo, drop = FALSE]
xreg_test  <- ts_test[,  combo, drop = FALSE]
fit <- auto.arima(ts_train[,'Sales'],
xreg        = xreg_train,
trace       = FALSE,
approximation=FALSE)
fcast <- forecast(fit, xreg = xreg_test)
acc <- accuracy(fcast, ts_test[,'Sales'])
results[[i]] <- tibble(
model       = combo_name,
arima       = as.character(fit$arma[c(1,6,2)] %>% paste(collapse=",")),
AICc        = fit$aicc,
BIC         = fit$bic,
RMSE_test   = acc["Test set","RMSE"],
MAE_test    = acc["Test set","MAE"],
MAPE_test   = acc["Test set","MAPE"]
)
i <- i + 1
}
}
# CONFIGURE TIME SERIES
sales_df = read.csv('/Users/zakbeltran/Documents/Documents/MathModFCO/cc6mon.csv', header=TRUE, stringsAsFactors=FALSE)
sales <- ts(sales_df[,'Sales'], start = c(2024,306), frequency = 365)
plot(sales)
# SPLIT TIME SERIES TO TRAIN AND TEST DATA
ts_train <- window(sales,start=c(2024,306),end=c(2025,90))
ts_test  <- window(sales,start=c(2025,90))
autoplot(ts_train,legendLabs = c("Train set 1"),xlab="Year",series="Train set") +
autolayer(ts_test,series = "Test set1") +
ggtitle("Data split 1")
# CHECK ACF
acf(ts_train)
pacf(ts_train)
fit_ARIMA <- auto.arima(ts_train, seasonal = FALSE, approximation=FALSE, trace=TRUE)
print(summary(fit_ARIMA))
checkresiduals(fit_ARIMA)
fcastA <- fit_ARIMA %>%
forecast(h = 32)
autoplot
plot(fcastA)
reg_cols <- c(3:9)
results <- list()
i <- 1
for (k in 1:length(reg_cols)) {
combos <- combn(reg_cols, k, simplify = FALSE)
for (combo in combos) {
combo_name <- paste0("cols_", paste(combo, collapse = "_"))
xreg_train <- ts_train[, combo, drop = FALSE]
xreg_test  <- ts_test[,  combo, drop = FALSE]
fit <- auto.arima(ts_train[,'Sales'],
xreg        = xreg_train,
trace       = FALSE,
approximation=FALSE)
fcast <- forecast(fit, xreg = xreg_test)
acc <- accuracy(fcast, ts_test[,'Sales'])
results[[i]] <- tibble(
model       = combo_name,
arima       = as.character(fit$arma[c(1,6,2)] %>% paste(collapse=",")),
AICc        = fit$aicc,
BIC         = fit$bic,
RMSE_test   = acc["Test set","RMSE"],
MAE_test    = acc["Test set","MAE"],
MAPE_test   = acc["Test set","MAPE"]
)
i <- i + 1
}
}
sales_df <- read.csv('/Users/zakbeltran/Documents/MathModFCO/cc6mon.csv',
header = TRUE, stringsAsFactors = FALSE)
sales_df <- read.csv('/Users/zakbeltran/Documents/Documents/MathModFCO/cc6mon.csv',
header = TRUE, stringsAsFactors = FALSE)
sales <- ts(sales_df, start = c(2024, 306), frequency = 365)
ts_train1 <- window(sales, start = c(2024, 306), end = c(2025,  90))
ts_test1  <- window(sales, start = c(2025,  90))
reg_cols <- c(3:9)
results <- list()
i <- 1
for (k in 1:length(reg_cols)) {
combos <- combn(reg_cols, k, simplify = FALSE)
for (combo in combos) {
combo_name <- paste0("cols_", paste(combo, collapse = "_"))
xreg_train <- ts_train1[, combo, drop = FALSE]
xreg_test  <- ts_test1[,  combo, drop = FALSE]
fit <- auto.arima(ts_train1[,'Sales'],
xreg        = xreg_train,
trace       = FALSE,
approximation=FALSE)
fcast <- forecast(fit, xreg = xreg_test)
acc <- accuracy(fcast, ts_test1[,'Sales'])
results[[i]] <- tibble(
model       = combo_name,
arima       = as.character(fit$arma[c(1,6,2)] %>% paste(collapse=",")),
AICc        = fit$aicc,
BIC         = fit$bic,
RMSE_test   = acc["Test set","RMSE"],
MAE_test    = acc["Test set","MAE"],
MAPE_test   = acc["Test set","MAPE"]
)
i <- i + 1
}
}
results_df <- bind_rows(results)
results_df %>%
filter(MAPE_test <= 50) %>%
arrange(RMSE_test) %>%
print(n = Inf)
# CONFIGURE TIME SERIES
sales_df = read.csv('/Users/zakbeltran/Documents/Documents/MathModFCO/cc6mon.csv', header=TRUE, stringsAsFactors=FALSE)
sales <- ts(sales_df[,'Sales'], start = c(2024,306), frequency = 365)
plot(sales)
# SPLIT TIME SERIES TO TRAIN AND TEST DATA
ts_train <- window(sales,start=c(2024,306),end=c(2025,90))
ts_test  <- window(sales,start=c(2025,90))
autoplot(ts_train,legendLabs = c("Train set 1"),xlab="Year",series="Train set") +
autolayer(ts_test,series = "Test set1") +
ggtitle("Data split 1")
# CHECK ACF
acf(ts_train)
pacf(ts_train)
fit_ARIMA <- auto.arima(ts_train, seasonal = FALSE, approximation=FALSE, trace=TRUE)
reg_cols <- c(3:9)
results <- list()
i <- 1
for (k in 1:length(reg_cols)) {
combos <- combn(reg_cols, k, simplify = FALSE)
for (combo in combos) {
combo_name <- paste0("cols_", paste(combo, collapse = "_"))
xreg_train <- ts_train[, combo, drop = FALSE]
xreg_test  <- ts_test[,  combo, drop = FALSE]
fit <- auto.arima(ts_train[,'Sales'],
xreg        = xreg_train,
trace       = FALSE,
approximation=FALSE)
fcast <- forecast(fit, xreg = xreg_test)
acc <- accuracy(fcast, ts_test[,'Sales'])
results[[i]] <- tibble(
model       = combo_name,
arima       = as.character(fit$arma[c(1,6,2)] %>% paste(collapse=",")),
AICc        = fit$aicc,
BIC         = fit$bic,
RMSE_test   = acc["Test set","RMSE"],
MAE_test    = acc["Test set","MAE"],
MAPE_test   = acc["Test set","MAPE"]
)
i <- i + 1
}
}
# CONFIGURE TIME SERIES
sales_df = read.csv('/Users/zakbeltran/Documents/Documents/MathModFCO/cc6mon.csv', header=TRUE, stringsAsFactors=FALSE)
sales <- ts(sales_df, start = c(2024,306), frequency = 365)
plot(sales)
# SPLIT TIME SERIES TO TRAIN AND TEST DATA
ts_train <- window(sales,start=c(2024,306),end=c(2025,90))
sales <- ts(sales_df, start = c(2024,306), frequency = 365)
plot(sales[,1])
plot(sales[,'Sales'])
# SPLIT TIME SERIES TO TRAIN AND TEST DATA
ts_train <- window(sales,start=c(2024,306),end=c(2025,90))
ts_test  <- window(sales,start=c(2025,90))
autoplot(ts_train[,'Sales'],legendLabs = c("Train set 1"),xlab="Year",series="Train set") +
autolayer(ts_test[,'Sales'],series = "Test set1") +
ggtitle("Data split 1")
# CHECK ACF
acf(ts_train[,1])
fit_ARIMA <- auto.arima(ts_train[,'Sales'], seasonal = FALSE, approximation=FALSE, trace=TRUE)
print(summary(fit_ARIMA))
checkresiduals(fit_ARIMA)
fcastA <- fit_ARIMA %>%
forecast(h = 32)
autoplot
plot(fcastA)
reg_cols <- c(3:9)
results <- list()
i <- 1
for (k in 1:length(reg_cols)) {
combos <- combn(reg_cols, k, simplify = FALSE)
for (combo in combos) {
combo_name <- paste0("cols_", paste(combo, collapse = "_"))
xreg_train <- ts_train[, combo, drop = FALSE]
xreg_test  <- ts_test[,  combo, drop = FALSE]
fit <- auto.arima(ts_train[,'Sales'],
xreg        = xreg_train,
trace       = FALSE,
approximation=FALSE)
fcast <- forecast(fit, xreg = xreg_test)
acc <- accuracy(fcast, ts_test[,'Sales'])
results[[i]] <- tibble(
model       = combo_name,
arima       = as.character(fit$arma[c(1,6,2)] %>% paste(collapse=",")),
AICc        = fit$aicc,
BIC         = fit$bic,
RMSE_test   = acc["Test set","RMSE"],
MAE_test    = acc["Test set","MAE"],
MAPE_test   = acc["Test set","MAPE"]
)
i <- i + 1
}
}
results_df <- bind_rows(results)
results_df %>%
filter(MAPE_test <= 50) %>%
arrange(RMSE_test) %>%
print(n = Inf)
results_df %>% # Shows results arranged by RMSE (Ascending)
filter(MAPE_test <= 50) %>%
arrange(RMSE_test) %>%
print(n = Inf)
xreg_train <- ts_train[, c(5, 8)]
xreg_test  <- ts_test[,  c(5, 8)]
fitX <- auto.arima(ts_train1[,'Sales'], xreg = xreg_train, trace=TRUE, approximation = FALSE)
print(summary(fitX))
checkresiduals(fitX)
fcast1 <- fitX %>%
forecast(xreg = xreg_test)
autoplot
plot(fcast1)
autoplot(ts_train1[,'Sales'],xlab ="Year",ylab="Daily Sales") +
autolayer(ts_test1[,'Sales'],series="Actual Sales",PI =FALSE) +
autolayer(fcast1,series="ARIMAX",PI =FALSE) +
ggtitle("Forecast obtained from ARIMA models")
autoplot(ts_train[,'Sales'],xlab ="Year",ylab="Daily Sales") +
autolayer(ts_test1[,'Sales'],series="Actual Sales",PI =FALSE) +
autolayer(fcast1,series="ARIMAX",PI =FALSE) +
ggtitle("Forecast obtained from ARIMA models")
autoplot(ts_train[,'Sales'],xlab ="Year",ylab="Daily Sales") +
accuracy(fcast1, ts_test[,"Sales"])
fcast1 <- fitX %>%
forecast(xreg = xreg_test)
autoplot
plot(fcast1)
accuracy(fcast1, ts_test[,"Sales"])
sales_df <- read.csv('/Users/zakbeltran/Documents/Documents/MathModFCO/cc6mon.csv',
header = TRUE, stringsAsFactors = FALSE)
sales <- ts(sales_df, start = c(2024, 306), frequency = 365)
ts_train1 <- window(sales, start = c(2024, 306), end = c(2025,  90))
ts_test1  <- window(sales, start = c(2025,  90))
reg_cols <- c(3:9)
results <- list()
i <- 1
for (k in 1:length(reg_cols)) {
combos <- combn(reg_cols, k, simplify = FALSE)
for (combo in combos) {
combo_name <- paste0("cols_", paste(combo, collapse = "_"))
xreg_train <- ts_train1[, combo, drop = FALSE]
xreg_test  <- ts_test1[,  combo, drop = FALSE]
fit <- auto.arima(ts_train1[,'Sales'],
xreg        = xreg_train,
trace       = FALSE,
approximation=FALSE)
fcast <- forecast(fit, xreg = xreg_test)
acc <- accuracy(fcast, ts_test1[,'Sales'])
results[[i]] <- tibble(
model       = combo_name,
arima       = as.character(fit$arma[c(1,6,2)] %>% paste(collapse=",")),
AICc        = fit$aicc,
BIC         = fit$bic,
RMSE_test   = acc["Test set","RMSE"],
MAE_test    = acc["Test set","MAE"],
MAPE_test   = acc["Test set","MAPE"]
)
i <- i + 1
}
}
results_df <- bind_rows(results)
results_df %>%
filter(MAPE_test <= 50) %>%  # Shows only models with <50% MAPE
arrange(MAPE_test) %>%
print(n = Inf)
# ================================================
library('ggplot2')
library('forecast')
library('tseries')
library('tidyverse')
# CONFIGURE TIME SERIES
sales_df = read.csv('data/collected-data/DailySales-and-XReg-6Months-Data.csv', header=TRUE, stringsAsFactors=FALSE)
setwd("~/Documents/ShortTermScalesForecasting_ARIMAX/R")
# ================================================
library('ggplot2')
library('forecast')
library('tseries')
library('tidyverse')
# CONFIGURE TIME SERIES
sales_df = read.csv('data/collected-data/DailySales-and-XReg-6Months-Data.csv', header=TRUE, stringsAsFactors=FALSE)
sales <- ts(sales_df, start = c(2024,306), frequency = 365)
plot(sales[,'Sales'])
# SPLIT TIME SERIES TO TRAIN AND TEST DATA
ts_train <- window(sales,start=c(2024,306),end=c(2025,90))
ts_test  <- window(sales,start=c(2025,90))
autoplot(ts_train[,'Sales'],xlab="Year",series="Train set") +
autolayer(ts_test[,'Sales'],series = "Test set") +
ggtitle("Data split 1")
# CHECK ACF AND TEST KPSS
acf(ts_train[,'Sales'])
pacf(ts_train[,'Sales'])
kpss.test(ts_train[,'Sales'])
